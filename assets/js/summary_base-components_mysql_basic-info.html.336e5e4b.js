"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3634],{1124:(a,e,l)=>{l.r(e),l.d(e,{comp:()=>t,data:()=>p});var i=l(6254);const n=l.p+"assets/img/mysql-architecture.f8692686.png",s=l.p+"assets/img/update.50e28e6a.jpg";var o=l(6497);const r=l.p+"assets/img/mysql-replication.955e17d6.png",d={},t=(0,l(6995).A)(d,[["render",function(a,e){return(0,i.uX)(),(0,i.CE)("div",null,e[0]||(e[0]=[(0,i.Fv)('<h1 id="mysql基础知识" tabindex="-1"><a class="header-anchor" href="#mysql基础知识"><span>MySQL基础知识</span></a></h1><h1 id="mysql架构" tabindex="-1"><a class="header-anchor" href="#mysql架构"><span>MySQL架构</span></a></h1><h2 id="架构说明" tabindex="-1"><a class="header-anchor" href="#架构说明"><span>架构说明</span></a></h2><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="sql执行过程" tabindex="-1"><a class="header-anchor" href="#sql执行过程"><span>sql执行过程</span></a></h2><h3 id="select执行过程" tabindex="-1"><a class="header-anchor" href="#select执行过程"><span>select执行过程</span></a></h3><p>select 普通查询sql执行过程如下:</p><ul><li>sql有客户端发送到服务端</li><li>查询缓存 <ul><li>如果query cache查询缓存开启</li><li>key语句,value缓存结果,查询该sql是否执行过</li><li><strong>查询缓存通常弊大于利</strong>。查询缓存失效率较高。每当对表进行更新时，该表的所有相应查询缓存条目都会失效并被清除。因此，存储结果所付出的努力可能是徒劳的，因为它们可以通过一次更新来清除。对于更新压力较高的数据库，查询缓存命中率可能会非常低。它仅在您拥有很少更新的静态表的情况下才有用。</li></ul></li><li>Parser 解析器:解析语法结构</li><li>Optimizer优化器: 优化器的主要作用是选择索引和表的连接顺序,确定执行计划</li><li>Executor执行器执行sql <ul><li>首先检查表的权限,如果没有返回权限不足的错误</li><li>打开表</li><li>调用引擎如innodb提供的接口获取扫描的第一行数据,匹配条件是否满足,如果满足加入结果集 <ul><li>无索引,调用表的第一行接口</li><li>有索引,调用符合条件的第一行的接口</li></ul></li><li>如果不符合,调用下一行</li><li>直至扫描了所有的行</li></ul></li></ul><h3 id="update执行过程" tabindex="-1"><a class="header-anchor" href="#update执行过程"><span>update执行过程</span></a></h3><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>update语句执行流程如下:</p><ul><li>客户端发送SQL到Server层连接器</li><li>解析器,对该语句进行解析,验证权限是否有权限操作(这里主要是表权限和操作权限)</li><li>分析器进行语法分析, 是否有语法错误</li><li>优化器生成执行计划, 并打开表,如果该表有DML操作,需要等待</li><li>执行器调用引擎层接口, <ul><li>在server层还会失效该表的查询缓存</li></ul></li><li>查找该语句对应的数据记录, <ul><li>如果这些记录未在buffer pool 中,则将数据从磁盘加载到buffer pool 中,即buffer pool中的data page</li></ul></li><li>redo log 和undo log <ul><li>将要修改的记录旧值保存到buffer pool 中undo log 的内存区域,也是链表</li><li>生成redo log buffer数据内容,并设置状态未prepare</li></ul></li><li>在data page中修改数据内容 <ul><li>如果该记录涉及非唯一索引,则要修改的非唯一索引,暂存change buffer <ul><li>下次读取该二级索引时,进行merge操作</li></ul></li></ul></li><li>记录修改信息,按照bin log event格式,记录到bin log cache中,事务提交后,由dump线程发送到slave的IO线程</li><li>update语句执行完成,执行commit 或者rollback操作</li><li>update执行commit <ul><li>将redo log buffer的数据进行commit,并根据innodb_flush_log_at_trx_commit 选项执行操作 <ul><li>0: 事务提交不立即向磁盘同步redo日志,后台任务去做</li><li>1: 事务提交时向磁盘同步,默认值</li><li>2: 事务提交时需要将redo log写到系统的缓冲区,并不需要真正写到磁盘</li></ul></li><li>bin log sync操作,sync_binlog默认为1 <ul><li>sync_binlog=0，禁用事务提交时bin log 同步到磁盘. 依赖操作系统去刷新到磁盘.好处: 最佳性能,坏处: 电源故障等发生时,事务已经提交,但是未同步bin log.</li><li>sync_binlog=1，事务提交时,同步到磁盘. 增加磁盘的写入次数. 因为电源事故或者突然崩溃事故, 自动恢复程序可以自动会滚事务,丢失的bin log都是prepare的</li><li>sync_binlog=n，n非0和1.代表n个事务提交后,同步磁盘. 如果磁盘写入增加,可能会产生负面影响,值越高,性能越高,但丢数据风险也就越高</li></ul></li></ul></li></ul><h2 id="innodb结构和缓存" tabindex="-1"><a class="header-anchor" href="#innodb结构和缓存"><span>InnoDB结构和缓存</span></a></h2><h3 id="innodb的结构" tabindex="-1"><a class="header-anchor" href="#innodb的结构"><span>InnoDB的结构</span></a></h3><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="buffer-pool" tabindex="-1"><a class="header-anchor" href="#buffer-pool"><span>Buffer pool</span></a></h3><h3 id="log-buffer" tabindex="-1"><a class="header-anchor" href="#log-buffer"><span>Log Buffer</span></a></h3><h3 id="doublewrite-buffer" tabindex="-1"><a class="header-anchor" href="#doublewrite-buffer"><span>DoubleWrite Buffer</span></a></h3><h4 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h4><p>DoubleWrite Buffer 时MySQL innodb存储引擎的一种机制,用于解决buffer pool 同步到磁盘时的一致性问题,提高数据完整性和可靠性.</p><p>DoubleWrite Buffer分为两部分:内存+磁盘文件.</p><ul><li>内存: 由128个MySQL页组成,大小为2MB</li><li>磁盘结构 <ul><li>8.0.20之前位于Innodb系统表空间</li><li>8.0.20之后位于doublewrite文件(可以指定目录)</li></ul></li></ul><p>MySQL是默认开启DoubleWrite buffer功能</p><h4 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h4><h1 id="索引" tabindex="-1"><a class="header-anchor" href="#索引"><span>索引</span></a></h1><h2 id="什么是索引" tabindex="-1"><a class="header-anchor" href="#什么是索引"><span>什么是索引</span></a></h2><h2 id="索引的分类" tabindex="-1"><a class="header-anchor" href="#索引的分类"><span>索引的分类</span></a></h2><h2 id="索引的数据结构" tabindex="-1"><a class="header-anchor" href="#索引的数据结构"><span>索引的数据结构</span></a></h2><h2 id="怎么创建索引" tabindex="-1"><a class="header-anchor" href="#怎么创建索引"><span>怎么创建索引</span></a></h2><h2 id="索引的使用" tabindex="-1"><a class="header-anchor" href="#索引的使用"><span>索引的使用</span></a></h2><h1 id="mysql的锁" tabindex="-1"><a class="header-anchor" href="#mysql的锁"><span>MySQL的锁</span></a></h1><h2 id="mysql中的锁介绍" tabindex="-1"><a class="header-anchor" href="#mysql中的锁介绍"><span>MySQL中的锁介绍</span></a></h2><h2 id="innodb行锁" tabindex="-1"><a class="header-anchor" href="#innodb行锁"><span>Innodb行锁</span></a></h2><h1 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span>事务</span></a></h1><h2 id="事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#事务的隔离级别"><span>事务的隔离级别</span></a></h2><h2 id="事务acid实现原理" tabindex="-1"><a class="header-anchor" href="#事务acid实现原理"><span>事务ACID实现原理</span></a></h2><h2 id="mysql-rr级别能解决幻读吗" tabindex="-1"><a class="header-anchor" href="#mysql-rr级别能解决幻读吗"><span>MySQL RR级别能解决幻读吗</span></a></h2><h1 id="mysql集群架构" tabindex="-1"><a class="header-anchor" href="#mysql集群架构"><span>MySQL集群架构</span></a></h1><h2 id="复制的原理" tabindex="-1"><a class="header-anchor" href="#复制的原理"><span>复制的原理</span></a></h2><h3 id="复制简介" tabindex="-1"><a class="header-anchor" href="#复制简介"><span>复制简介</span></a></h3><blockquote><p>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步.</p></blockquote><p>MySQL 支持两种复制方式: 基于行的复制和基于语句的复制. 这两种方式都是通过在主库记录bin log日志,然后同步到从库,在从库重放bin log日志,来实现的异步的数据复制.所以这意味着,主从架构异步复制的方式会有短暂的数据不一致,当前这个时间可大可小,受限制于网络、语句大小等.</p><h3 id="复制的工作流程" tabindex="-1"><a class="header-anchor" href="#复制的工作流程"><span>复制的工作流程</span></a></h3><p>复制有三个步骤:</p><ul><li>主服务器生成bin log</li><li>从库将主库上的bin log 复制到自己的中继(relay log)日志</li><li>从库读取中继日志中的事件,将其重放到从库数据之上</li></ul><h3 id="复制数据格式" tabindex="-1"><a class="header-anchor" href="#复制数据格式"><span>复制数据格式</span></a></h3><h4 id="基于语句的复制" tabindex="-1"><a class="header-anchor" href="#基于语句的复制"><span>基于语句的复制</span></a></h4><blockquote><p>--binlog-format=STATEMENT</p></blockquote><p>基于语句的复制原理是: 主库会记录写操作的sql(insert\\delete\\update) ,从库同步日志后,再执行一遍SQL.</p><p><strong>优点:</strong> 日志比较紧凑、日志比较小,不会占用太多带宽. mysqlbinlog工具就是基于语句复制实现的工具.</p><p><strong>缺点:</strong></p><ul><li>同一条日志在主库、从库的执行结果可能不同,如时间戳问题</li><li>sql执行必须串行.</li></ul><h4 id="基于行的复制" tabindex="-1"><a class="header-anchor" href="#基于行的复制"><span>基于行的复制</span></a></h4><blockquote><p>--binlog-format=ROW</p></blockquote><p>基于行的复制: 记录并复制数据变更的具体行.</p><h4 id="混合日志记录" tabindex="-1"><a class="header-anchor" href="#混合日志记录"><span>混合日志记录</span></a></h4><blockquote><p>--binlog-format=MIXED</p></blockquote><p>默认情况下使用基于语句的日志记录，但在某些情况下，日志记录模式会自动切换到基于行的日志记录，</p><h3 id="复制的模式" tabindex="-1"><a class="header-anchor" href="#复制的模式"><span>复制的模式</span></a></h3><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>MySQL 主从复制默认是异步的模式。MySQL增删改操作会全部记录在 Binlog 中，当 slave 节点连接 master 时，会主动从 master 处获取最新的 Binlog 文件。并把 Binlog 存储到本地的 relay log 中，然后去执行 relay log 的更新内容。通过位点同步的原理如下：</p><p>**1、**主库会生成多个 binlog 日志文件。</p><p>**2、**从库的I/O 线程请求指定文件和指定位置的 binlog 日志文件（位点）。</p><p>**3、**主库 dump 线程获取指定位点的 binlog 日志。</p><p>**4、**主库按照从库发送给来的位点信息读取 binlog，然后推送 binlog 给从库。</p><p>**5、**从库将得到的 binlog 写到本地的 relay log (中继日志) 文件中。</p><p>**6、**从库的 SQL 线程读取和解析 relay log 文件。</p><p>**7、**从库的 SQL 线程重放 relay log 中的命令。</p><p>当我们使用位点同步的方式时，两种场景下的操作步骤比较复杂。</p><p><strong>存在痛点</strong></p><p>痛点1：首次开启主从复制的步骤复杂</p><ul><li>第一次开启主从同步时，要求从库和主库是一致的。</li><li>找到主库的 binlog 位点。</li><li>设置从库的 binlog 位点。</li><li>开启从库的复制线程。</li></ul><p>痛点2：恢复主从复制的步骤复杂</p><ul><li>找到从库复制线程停止时的位点。</li><li>解决复制异常的事务。无法解决时就需要手动跳过指定类型的错误，比如通过设置slave_skip_errors=1032,1062。当然这个前提条件是跳过这类错误是无损的。（1062 错误是插入数据时唯一键冲突；1032 错误是删除数据时找不到行）</li></ul><h4 id="异步模式" tabindex="-1"><a class="header-anchor" href="#异步模式"><span>异步模式</span></a></h4><p>默认情况下主从复制的是异步的.</p><p>异步一: dump 异步即主库写入bin log变更后,通知 dump 线程,将变更事件通知给从库IO线程</p><p>异步二: 从库IO线程收到事件后,将事件顺序写入到relay log (中继日志),然后SQL异步读取将变更更新到从库</p><h4 id="同步模式" tabindex="-1"><a class="header-anchor" href="#同步模式"><span>同步模式</span></a></h4><p>MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</p><h4 id="半同步模式" tabindex="-1"><a class="header-anchor" href="#半同步模式"><span>半同步模式</span></a></h4><p><strong>该模式可以解决异步复制的数据丢失问题</strong></p><p>MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</p><p>在master执行完毕后，commit之前，slave的io进程开始把Binlog写入到relaylog中，写完之后，反馈给master，master收到任何一个slave的反馈后，执行commit并返回结果给客户端。半同步的机制减少了主从数据不同步的问题，但是也牺牲了一部分主库的性能，比异步复制至少多了一个tcp的往返时间。</p><h4 id="延迟模式" tabindex="-1"><a class="header-anchor" href="#延迟模式"><span>延迟模式</span></a></h4><p>在异步复制基础上,人为设定主库和从库的数据同步延迟时间.</p><h3 id="gtid" tabindex="-1"><a class="header-anchor" href="#gtid"><span>GTID</span></a></h3><blockquote><p>GTID : 全局事务标识符</p><p>GTID的主要目的是简化主从复制的管理,提高数据复制的可靠性和效率</p></blockquote><h4 id="什么是gtid" tabindex="-1"><a class="header-anchor" href="#什么是gtid"><span>什么是GTID</span></a></h4><p><code>GTID</code> 指的是全局事务 ID，全称是 <code>Global Transaction Identifier</code>，具有如下特点：</p><ul><li>GTID事务是全局唯一性的，并且一个事务对应一个GTID值。</li><li>一个GTID值在同一个MySQL实例上只会执行一次。</li></ul><p>GTID 由 <code>server_uuid</code> + <code>tid</code> 组成，其中：</p><ul><li><strong>server_uuid：</strong> <code>server_uuid</code> 是在 Mysql 首次启动过程中自动生成的一个 <code>uuid(128位)</code> 随机值，生成后会将该值存储到数据目录的<code>auto.cnf</code>文件中。</li><li><strong>tid：</strong> 代表了该实例上已经提交的事务数量，并且随着事务提交单调递增，所以GTID能够保证每个MySQL实例事务的执行（不会重复执行同一个事务，并且会补全没有执行的事务）。</li></ul><p>其组成样式如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> 26630fed-fe68-11ec-b051-000c29509871:1-27</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="gtid-复制模式" tabindex="-1"><a class="header-anchor" href="#gtid-复制模式"><span>GTID 复制模式</span></a></h4><p>为了解决基于 Binlog 复制模式的痛点，于是在 MySQL 5.6 里面，提供了新的数据恢复思路，这就是基于GTID的复制模式。MySQL能够通过内部机制 GTID 自动找点同步，并且通过 GTID可以保证每个主库提交的事务在集群中都有唯一的一个事务ID，强化了数据库主从的一致性和故障恢复数据的容错能力，在主库宕机发生主从切换的情况下，GTID方式可以让其他从库自动找到新主库复制的位置。而且GTID可以忽略已经执行过的事务，减少了数据发生错误的概率。GTID 同步的原理如下：</p><ul><li>主节点执行事务提交前会产生一个 <code>GTID</code>，其会随着事务一起记录到 <code>binlog</code> 日志中。</li><li>从节点 <code>I/O Thread</code> 会读取主节点的 <code>binlog</code> 日志文件并存储在从节点的 <code>relaylog</code> 日志中。从节点将主节点的 <code>GTID</code> 这个值配置到 <code>gtid_next</code> 中，即下一个要读取的 GTID 值。</li><li>从节点SQL线程从relay log中读取 <code>gtid_next</code> 中的值，然后查找自己的 <code>binlog</code> 日志中是否有这个 <code>GTID</code>。</li><li>如果有这个记录，说明这个 <code>GTID</code> 的事务已经执行过了，就忽略掉。</li><li>如果没有这个记录，从节点会从relay log中执行该GTID的事务，并记录到自己的 <code>binlog</code> 日志中。同时在读取执行事务前会先检查其他 <code>session</code> 中是否持有该 <code>GTID</code>，确保不被重复执行。</li></ul><h4 id="gtid相较与传统复制的优势" tabindex="-1"><a class="header-anchor" href="#gtid相较与传统复制的优势"><span>GTID相较与传统复制的优势</span></a></h4><ul><li>主从搭建更加简便，不用手动特地指定position位置。</li><li>复制集群内有一个统一的标识，识别、管理上更方便。</li><li>故障转移failover更容易，不用像传统复制那样需要找 log_File 和 log_Position的位置。</li><li>通常情况下GTID是连续没有空洞的，更能保证数据的一致性。</li><li>相对于ROW复制模式，数据安全性更高，切换更简单。</li><li>比传统的复制更加安全，一个GTID在一个MySQL实例上只会执行一次，避免重复执行导致数据混乱或者主从不一致。</li></ul><h4 id="gtid-使用中的限制条件" tabindex="-1"><a class="header-anchor" href="#gtid-使用中的限制条件"><span>GTID 使用中的限制条件</span></a></h4><p>GTID 复制是针对事务来说的，一个事务只对应一个 GTID，好多的限制就在于此。其中主要限制如下：</p><ul><li>在一个复制组中，必须要求统一开启GTID或者是关闭GTID。</li><li>开启GTID需要重启(5.7除外)</li><li>不支持 <code>create table table_name select * from table_name</code>语句复制。</li></ul><blockquote><p>原理：</p><p>会生成两个sql，一个是DDL创建表SQL，一个是insert into 插入数据的sql。由于DDL会导致自动提交，所以这个sql至少需要两个GTID，但是GTID模式下，只能给这个sql生成一个GTID )</p></blockquote><ul><li>不允许在一个事务中既包含事务表（使用 <code>InnoDB</code> 存储引擎的表）的操作又包含非事务表（使用 <code>MyISAM</code> 存储引擎的表）。</li><li>不支持创建或删除临时表操作，如 <code>CREATE TEMPORARY TABLE or DROP TEMPORARY TABLE</code> 语句操作。</li><li>使用 GTID 复制从库跳过错误时，不支持执行该 <code>sql_slave_skip_counter</code> 参数的语法，传统复制可以使用这个命令跳过事务。</li></ul><h2 id="集群架构模式" tabindex="-1"><a class="header-anchor" href="#集群架构模式"><span>集群架构模式</span></a></h2><h2 id="星型拓扑" tabindex="-1"><a class="header-anchor" href="#星型拓扑"><span>星型拓扑</span></a></h2><p>待补充</p><h2 id="链式拓扑" tabindex="-1"><a class="header-anchor" href="#链式拓扑"><span>链式拓扑</span></a></h2><p>待补充</p>',110)]))}]]),p=JSON.parse('{"path":"/summary/base-components/mysql/basic-info.html","title":"MySQL基础知识","lang":"zh-CN","frontmatter":{"description":"MySQL基础知识 MySQL架构 架构说明 sql执行过程 select执行过程 select 普通查询sql执行过程如下: sql有客户端发送到服务端 查询缓存 如果query cache查询缓存开启 key语句,value缓存结果,查询该sql是否执行过 查询缓存通常弊大于利。查询缓存失效率较高。每当对表进行更新时，该表的所有相应查询缓存条目都会...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/notes-base/summary/base-components/mysql/basic-info.html"}],["meta",{"property":"og:site_name","content":"Offer收割机"}],["meta",{"property":"og:title","content":"MySQL基础知识"}],["meta",{"property":"og:description","content":"MySQL基础知识 MySQL架构 架构说明 sql执行过程 select执行过程 select 普通查询sql执行过程如下: sql有客户端发送到服务端 查询缓存 如果query cache查询缓存开启 key语句,value缓存结果,查询该sql是否执行过 查询缓存通常弊大于利。查询缓存失效率较高。每当对表进行更新时，该表的所有相应查询缓存条目都会..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-11T08:46:41.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-11T08:46:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL基础知识\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-11T08:46:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Jason\\",\\"url\\":\\"https://jason.com\\"}]}"]]},"git":{"createdTime":1744361201000,"updatedTime":1744361201000,"contributors":[{"name":"Jason Statham","username":"Jason Statham","email":"xpt_notes@163.com","commits":1,"url":"https://github.com/Jason Statham"}]},"readingTime":{"minutes":12.11,"words":3632},"filePathRelative":"summary/base-components/mysql/basic-info.md","localizedDate":"2025年4月11日","autoDesc":true}')},6497:(a,e,l)=>{a.exports=l.p+"assets/img/innodb.74e08616.png"},6995:(a,e)=>{e.A=(a,e)=>{const l=a.__vccOpts||a;for(const[a,i]of e)l[a]=i;return l}}}]);