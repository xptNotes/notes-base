"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7186],{6995:(s,i)=>{i.A=(s,i)=>{const a=s.__vccOpts||s;for(const[s,e]of i)a[s]=e;return a}},9374:(s,i,a)=>{a.r(i),a.d(i,{comp:()=>l,data:()=>t});var e=a(6254);const n={},l=(0,a(6995).A)(n,[["render",function(s,i){return(0,e.uX)(),(0,e.CE)("div",null,i[0]||(i[0]=[(0,e.Fv)('<h1 id="mysql面试汇总" tabindex="-1"><a class="header-anchor" href="#mysql面试汇总"><span>MySQL面试汇总</span></a></h1><h1 id="索引" tabindex="-1"><a class="header-anchor" href="#索引"><span>索引</span></a></h1><h2 id="如何创建索引" tabindex="-1"><a class="header-anchor" href="#如何创建索引"><span>如何创建索引?</span></a></h2><h2 id="判断是否走索引" tabindex="-1"><a class="header-anchor" href="#判断是否走索引"><span>判断是否走索引?</span></a></h2><h3 id="or情况" tabindex="-1"><a class="header-anchor" href="#or情况"><span>OR情况</span></a></h3><p>MySQL查询中使用<code>OR</code>并不意味着索引一定会失效。索引是否被使用取决于多个因素，包括查询的具体结构、涉及的列以及这些列上索引的存在与定义。在某些情况下，使用<code>OR</code>可能导致查询优化器决定不使用索引， 而在其他情况下，它仍然可以利用索引进行查询。以下是一些影响索引使用的情况：</p><ol><li><strong>复合索引中的列顺序</strong>：如果查询条件使用<code>OR</code>连接的列都是复合索引的一部分，并且遵循索引中的列顺序，那么MySQL可能会使用索引。</li><li><strong>索引合并优化</strong>：在某些情况下，MySQL可以使用索引合并优化策略，即结合多个索引来满足使用<code>OR</code>连接的查询条件。</li><li><strong>查询选择性</strong>：如果<code>OR</code>条件中的每个部分都非常选择性（即匹配的行数很少），那么即使使用<code>OR</code>，MySQL也可能使用索引。</li><li><strong>全表扫描可能更高效</strong>：如果使用<code>OR</code>的查询条件匹配了表中的大部分行，那么全表扫描可能比使用索引更高效，因此MySQL查询优化器可能选择不使用索引。</li><li><strong>类型转换和函数</strong>：如果<code>OR</code>连接的条件中涉及到对索引列的类型转换或者使用了函数，那么索引可能不会被使用。</li></ol><p>总的来说，是否使用索引以及如何使用索引是由MySQL的查询优化器决定的，它会基于统计信息和成本估算来选择最佳的执行计划。如果担心<code>OR</code>操作符导致索引失效，可以使用<code>EXPLAIN</code>语句来查看查询的执行计划，了解是否有索引被使用以及如何使用。此外，通过调整查询结构或创建适当的索引，可以优化查询性能，使其更有可能利用索引</p><p>要保证使用<code>OR</code>时一定使用索引，需要确保查询优化器认为使用索引是最优选择。这通常涉及到确保查询中的每个部分都能够匹配到有效的索引，并且这些索引能够提供比全表扫描更好的性能。以下是一些确保使用<code>OR</code>时索引被使用的策略：</p><ol><li><p><strong>使用覆盖索引</strong>：确保<code>OR</code>查询中的所有列都包含在一个或多个索引中。例如，如果有一个索引<code>idx_name</code>覆盖了<code>first_name</code>和<code>last_name</code>字段，那么以下查询可能会使用该索引：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sql</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 代码解读</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">复制代码SELECT first_name, last_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> first_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Alice&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> OR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> last_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Smith&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>索引合并</strong>：如果<code>OR</code>查询的每个条件都对应一个索引，MySQL可能会通过索引合并优化来使用这些索引。例如，如果<code>first_name</code>和<code>last_name</code>各自有索引，以下查询可能会使用索引合并：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sql</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 代码解读</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">复制代码SELECT * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> first_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Alice&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> OR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> last_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Smith&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>使用<code>UNION</code>或<code>UNION ALL</code></strong>：如果无法确保<code>OR</code>查询直接使用索引，可以将查询分解为多个使用<code>UNION</code>或<code>UNION ALL</code>的子查询，每个子查询分别使用索引。例如：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sql</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 代码解读</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">复制代码SELECT * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> first_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Alice&#39;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">UNION ALL</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> last_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Smith&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>强制索引</strong>：在某些情况下，可以使用<code>FORCE INDEX</code>语句来强制查询使用特定的索引。这应该谨慎使用，因为它覆盖了MySQL查询优化器的决策。例如：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sql</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 代码解读</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">复制代码SELECT * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FORCE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (idx_first_name) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> first_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Alice&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> OR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> last_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Smith&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>请注意，即使采取了上述措施，仍然不能百分百保证<code>OR</code>查询一定会使用索引，因为MySQL查询优化器会基于统计信息和成本模型来做出决定。如果它判断使用索引的成本高于全表扫描，它可能会选择不使用索引。 因此，最好的做法是使用<code>EXPLAIN</code>语句来查看查询的执行计划，并根据实际情况调整查询和索引策略</p><h2 id="b-tree数据结构" tabindex="-1"><a class="header-anchor" href="#b-tree数据结构"><span>B+Tree数据结构</span></a></h2><h3 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h3><h3 id="千万级数据层高估算" tabindex="-1"><a class="header-anchor" href="#千万级数据层高估算"><span>千万级数据层高估算</span></a></h3>',14)]))}]]),t=JSON.parse('{"path":"/summary/base-components/mysql/mysql-interview-summary.html","title":"MySQL面试汇总","lang":"zh-CN","frontmatter":{"description":"MySQL面试汇总 索引 如何创建索引? 判断是否走索引? OR情况 MySQL查询中使用OR并不意味着索引一定会失效。索引是否被使用取决于多个因素，包括查询的具体结构、涉及的列以及这些列上索引的存在与定义。在某些情况下，使用OR可能导致查询优化器决定不使用索引， 而在其他情况下，它仍然可以利用索引进行查询。以下是一些影响索引使用的情况： 复合索引中的...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/notes-base/summary/base-components/mysql/mysql-interview-summary.html"}],["meta",{"property":"og:site_name","content":"Offer收割机"}],["meta",{"property":"og:title","content":"MySQL面试汇总"}],["meta",{"property":"og:description","content":"MySQL面试汇总 索引 如何创建索引? 判断是否走索引? OR情况 MySQL查询中使用OR并不意味着索引一定会失效。索引是否被使用取决于多个因素，包括查询的具体结构、涉及的列以及这些列上索引的存在与定义。在某些情况下，使用OR可能导致查询优化器决定不使用索引， 而在其他情况下，它仍然可以利用索引进行查询。以下是一些影响索引使用的情况： 复合索引中的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-11T08:46:41.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-11T08:46:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL面试汇总\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-11T08:46:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Jason\\",\\"url\\":\\"https://jason.com\\"}]}"]]},"git":{"createdTime":1744361201000,"updatedTime":1744361201000,"contributors":[{"name":"Jason Statham","username":"Jason Statham","email":"xpt_notes@163.com","commits":1,"url":"https://github.com/Jason Statham"}]},"readingTime":{"minutes":3.66,"words":1099},"filePathRelative":"summary/base-components/mysql/mysql-interview-summary.md","localizedDate":"2025年4月11日","autoDesc":true}')}}]);