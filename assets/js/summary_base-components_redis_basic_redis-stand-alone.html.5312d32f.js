"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9263],{5156:(e,a,i)=>{i.r(a),i.d(a,{comp:()=>r,data:()=>l});var s=i(6254);const d={},r=(0,i(6995).A)(d,[["render",function(e,a){return(0,s.uX)(),(0,s.CE)("div",null,a[0]||(a[0]=[(0,s.Fv)('<h1 id="redis单机原理知识总结" tabindex="-1"><a class="header-anchor" href="#redis单机原理知识总结"><span>Redis单机原理知识总结</span></a></h1><h1 id="一、redis简介" tabindex="-1"><a class="header-anchor" href="#一、redis简介"><span>一、Redis简介</span></a></h1><h2 id="redis为什么这么快" tabindex="-1"><a class="header-anchor" href="#redis为什么这么快"><span>Redis为什么这么快?</span></a></h2><p>redis为什么这么快的原因主要取决于以下几个方面:</p><ul><li>Redis的操作是完全基于内存完成的.</li><li>Redis高效的数据结构,整体来说可以是理解为是一个大的HashMap,查找操作复杂度为O(1)</li><li>Redis处理客户端请求是单线程的,避免了多线程的上下文切换和线程竞争开销</li><li>网络层面,底层采取了select和epoll多路复用的高效非阻塞IO模型</li><li>Redis协议RESP比较简单,避免了复杂请求的解析开销.</li></ul><h1 id="二、redis-架构" tabindex="-1"><a class="header-anchor" href="#二、redis-架构"><span>二、Redis 架构</span></a></h1><h1 id="三、redis数据结构和对象" tabindex="-1"><a class="header-anchor" href="#三、redis数据结构和对象"><span>三、Redis数据结构和对象</span></a></h1><h1 id="四、redis内存管理" tabindex="-1"><a class="header-anchor" href="#四、redis内存管理"><span>四、Redis内存管理</span></a></h1><h2 id="内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#内存淘汰策略"><span>内存淘汰策略</span></a></h2><p>当Redis内存不够用时,redis会根据设置的淘汰策略,进行对应操作对:</p><ul><li>no-eviction: 写操作拒绝,读操作继续提供</li><li>设置过期时间的key <ul><li>Volatile-random : 随机删除</li><li>Volatile-lru: 近似lru算法删除</li><li>Volatile-ttl : 将要临近过期的key删除</li></ul></li><li>未设置过期时间的key <ul><li>allkey-random: 所有key随机删除</li><li>allkey-lru: 所有key根据近似lru算法删除</li></ul></li></ul><p>后续又新增了两种:</p><ul><li>allkey-lfu: 所有key空间lfu算法删除</li><li>Volatile-lfu:设置了过期key空间lfu算法删除</li></ul><h2 id="redis键删除策略" tabindex="-1"><a class="header-anchor" href="#redis键删除策略"><span>Redis键删除策略</span></a></h2><p>Redis键过期后支持三种删除策略:</p><ul><li>定时删除:设置了定时器,键过期了,定时器立即删除改键, <ul><li>优点: 对内存友好</li><li>缺点: 对cpu不友好,如果过期键太多,cpu消耗大</li></ul></li><li>定期删除 <ul><li>Redis默认每隔100ms就会随机抽取一些设置过期时间的key进行检测,如果过期就会删除</li></ul></li><li>惰性删除 <ul><li>键过期时,留在内存不做处理,当有请求访问该key时,如果过期就删除,否则返回key对应的信息.</li></ul></li></ul><p>redis默认采用定期+惰性删除.</p><h1 id="五、redis持久化" tabindex="-1"><a class="header-anchor" href="#五、redis持久化"><span>五、Redis持久化</span></a></h1><p>Redis持久化的方式支持三种:RDB、AOF、混合持久化.</p><p>在4.X版本之前<code>Redis</code>只支持<code>AOF</code>以及<code>RDB</code>两种形式持久化，但是因为<code>AOF</code>与<code>RDB</code>都存在各自的缺陷，所以在<code>4.x</code>版本之后<code>Redis</code>还提供一种新的持久化机制：混合型持久化（但是最终生成的文件还是<code>.AOF</code>）</p><h2 id="rdb" tabindex="-1"><a class="header-anchor" href="#rdb"><span>RDB</span></a></h2><h3 id="rdb设置" tabindex="-1"><a class="header-anchor" href="#rdb设置"><span>RDB设置</span></a></h3><h3 id="rdb原理" tabindex="-1"><a class="header-anchor" href="#rdb原理"><span>RDB原理</span></a></h3><h3 id="rdb优缺点" tabindex="-1"><a class="header-anchor" href="#rdb优缺点"><span>RDB优缺点</span></a></h3><h2 id="aof" tabindex="-1"><a class="header-anchor" href="#aof"><span>AOF</span></a></h2><h2 id="混合持久化" tabindex="-1"><a class="header-anchor" href="#混合持久化"><span>混合持久化</span></a></h2>',26)]))}]]),l=JSON.parse('{"path":"/summary/base-components/redis/basic/redis-stand-alone.html","title":"Redis单机原理知识总结","lang":"zh-CN","frontmatter":{"description":"Redis单机原理知识总结 一、Redis简介 Redis为什么这么快? redis为什么这么快的原因主要取决于以下几个方面: Redis的操作是完全基于内存完成的. Redis高效的数据结构,整体来说可以是理解为是一个大的HashMap,查找操作复杂度为O(1) Redis处理客户端请求是单线程的,避免了多线程的上下文切换和线程竞争开销 网络层面,底...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/notes-base/summary/base-components/redis/basic/redis-stand-alone.html"}],["meta",{"property":"og:site_name","content":"Offer收割机"}],["meta",{"property":"og:title","content":"Redis单机原理知识总结"}],["meta",{"property":"og:description","content":"Redis单机原理知识总结 一、Redis简介 Redis为什么这么快? redis为什么这么快的原因主要取决于以下几个方面: Redis的操作是完全基于内存完成的. Redis高效的数据结构,整体来说可以是理解为是一个大的HashMap,查找操作复杂度为O(1) Redis处理客户端请求是单线程的,避免了多线程的上下文切换和线程竞争开销 网络层面,底..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-10T13:01:21.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-10T13:01:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis单机原理知识总结\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-10T13:01:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Jason\\",\\"url\\":\\"https://jason.com\\"}]}"]]},"git":{"createdTime":1741259660000,"updatedTime":1746882081000,"contributors":[{"name":"Jason Statham","username":"Jason Statham","email":"xpt_notes@163.com","commits":4,"url":"https://github.com/Jason Statham"}]},"readingTime":{"minutes":2.04,"words":611},"filePathRelative":"summary/base-components/redis/basic/redis-stand-alone.md","localizedDate":"2025年3月6日","autoDesc":true}')},6995:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,s]of a)i[e]=s;return i}}}]);