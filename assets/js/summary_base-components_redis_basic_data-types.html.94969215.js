"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3987],{4500:(s,a,n)=>{n.r(a),n.d(a,{comp:()=>t,data:()=>r});var i=n(6254);const e=n.p+"assets/img/Redis底层数据原理.d3e2e237.png",l=n.p+"assets/img/redis-string.4db78de4.jpg",p=n.p+"assets/img/SkipList.bbdd00f4.jpg",d={},t=(0,n(6995).A)(d,[["render",function(s,a){return(0,i.uX)(),(0,i.CE)("div",null,a[0]||(a[0]=[(0,i.Fv)('<h1 id="redis数据结构与对象" tabindex="-1"><a class="header-anchor" href="#redis数据结构与对象"><span>Redis数据结构与对象</span></a></h1><blockquote><p>在redis数据库中每个键值对key-value都是有对象组成的,其中key都是字符串对象,value对象类型有五种:</p><p>字符串对象、列表对象、哈希对象、集合对象、有序集合对象.</p><p>这五种数据对象是提供给用户直接使用的,其底层实现主要依赖以下8种数据结构:</p><p>简单动态字符串、字典表、双向链表、跳表、整数集合、压缩列表、快速列表</p></blockquote><h1 id="redis对象系统" tabindex="-1"><a class="header-anchor" href="#redis对象系统"><span>Redis对象系统</span></a></h1><figure><img src="'+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="redis数据类型" tabindex="-1"><a class="header-anchor" href="#redis数据类型"><span>Redis数据类型</span></a></h1><h2 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串"><span>字符串</span></a></h2><h3 id="基础使用" tabindex="-1"><a class="header-anchor" href="#基础使用"><span>基础使用</span></a></h3><h4 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h4><blockquote><p>redis字符串是二进制安全的</p><p>redis字符串可以存储字节序列,包括文本、序列化对象、二进制数组</p><p>redis字符串特殊功能: 计数器、bitmap(位图)</p></blockquote><h4 id="限制" tabindex="-1"><a class="header-anchor" href="#限制"><span>限制</span></a></h4><h5 id="大小" tabindex="-1"><a class="header-anchor" href="#大小"><span>大小</span></a></h5><blockquote><p>默认情况下,redis字符串最大大小为512MB,</p><p>所以redis的key最大为512MB</p></blockquote><h5 id="扩容-缩容" tabindex="-1"><a class="header-anchor" href="#扩容-缩容"><span>扩容/缩容</span></a></h5><p>空间预分配:</p><blockquote><p>如果大小小于1MB,每次扩容增加一倍,缩容减少1倍</p><p>有一个注意点:如果字符串类型不同,需要重新分配内容,并将旧数据copy到新空间</p><p>sds类型分为:SDS_TYPE_5、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64</p><p>SDS_TYPE_5：这个比较特殊，注释上说未被使用，但是也不完全准确，无论如何这个类型都不是我们讨论的重点。<br> SDS_TYPE_8: 当len 小于 1 &lt;&lt; 8，也就是小于256时，变量len和alloc用uint8类型。<br> SDS_TYPE_16: 当len 小于 1 &lt;&lt; 16，也就是小于65536时，变量len和alloc用uint16类型。<br> SDS_TYPE_32: 当len 小于 1 &lt;&lt; 32，也就是小于4294967296时，变量len和alloc用uint32类型。<br> SDS_TYPE_64: 当len 大于等于 1 &lt;&lt; 32，也就是大于等于4294967296时，变量len和alloc用uint64类型。</p></blockquote><p><strong>惰性空间释放：</strong></p><p>惰性空间释放用于优化SDS的字符串缩短操作，当SDS需要缩短保存的字符串时，程序并不立即使用内存分配来回收缩短后多出来的字节，而是使用free属性将这些字节数量记录起来，并等待将来使用。</p><h3 id="特殊使用" tabindex="-1"><a class="header-anchor" href="#特殊使用"><span>特殊使用</span></a></h3><h4 id="计数器" tabindex="-1"><a class="header-anchor" href="#计数器"><span>计数器</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>incr key    对key的数值增加1</span></span>\n<span class="line"><span>incrby key step 对key的数值增加step</span></span>\n<span class="line"><span>decr key  对key的数值减少1</span></span>\n<span class="line"><span>decrby key step 对key的数值减少step</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="位图" tabindex="-1"><a class="header-anchor" href="#位图"><span>位图</span></a></h4><p><strong>介绍</strong></p><blockquote><p>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type which is treated like a bit vector. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2^32 different bits.<br> 位图不是一种实际的数据类型，而是在 String 类型上定义的一组面向位的作，该类型被视为位向量。由于字符串是二进制安全 blob，其最大长度为 512 MB，因此它们适用于设置多达 2^32 个不同的位。</p><p>redis官方说明</p></blockquote><p><strong>常用命令</strong></p><p>命令主要分为两种:</p><ol><li>单个操作:获取指定bit的值,或者设置指定位置的bit</li><li>组操作: 如给定区间内设置bit的数量等</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>getbit  获取指定位置的bit值</span></span>\n<span class="line"><span>setbit  设置指定位置 bit值</span></span>\n<span class="line"><span>bitcount count指定区间的1总数</span></span>\n<span class="line"><span>bitops 查找第一个0或者1的位置</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h3><h4 id="sds" tabindex="-1"><a class="header-anchor" href="#sds"><span>SDS</span></a></h4><p><strong>redis6版本</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>redis6</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span>\n<span class="line"><span> * However is here to document the layout of type 5 SDS strings. */</span></span>\n<span class="line"><span>struct __attribute__ ((__packed__)) sdshdr5 {</span></span>\n<span class="line"><span>    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */</span></span>\n<span class="line"><span>    char buf[];</span></span>\n<span class="line"><span>};</span></span>\n<span class="line"><span>struct __attribute__ ((__packed__)) sdshdr8 {</span></span>\n<span class="line"><span>    uint8_t len; /* used */</span></span>\n<span class="line"><span>    uint8_t alloc; /* excluding the header and null terminator */</span></span>\n<span class="line"><span>    unsigned char flags; /* 3 lsb of type, 5 unused bits */</span></span>\n<span class="line"><span>    char buf[];</span></span>\n<span class="line"><span>};</span></span>\n<span class="line"><span>struct __attribute__ ((__packed__)) sdshdr16 {</span></span>\n<span class="line"><span>    uint16_t len; /* used */</span></span>\n<span class="line"><span>    uint16_t alloc; /* excluding the header and null terminator */</span></span>\n<span class="line"><span>    unsigned char flags; /* 3 lsb of type, 5 unused bits */</span></span>\n<span class="line"><span>    char buf[];</span></span>\n<span class="line"><span>};</span></span>\n<span class="line"><span>struct __attribute__ ((__packed__)) sdshdr32 {</span></span>\n<span class="line"><span>    uint32_t len; /* used */</span></span>\n<span class="line"><span>    uint32_t alloc; /* excluding the header and null terminator */</span></span>\n<span class="line"><span>    unsigned char flags; /* 3 lsb of type, 5 unused bits */</span></span>\n<span class="line"><span>    char buf[];</span></span>\n<span class="line"><span>};</span></span>\n<span class="line"><span>struct __attribute__ ((__packed__)) sdshdr64 {</span></span>\n<span class="line"><span>    uint64_t len; /* used */</span></span>\n<span class="line"><span>    uint64_t alloc; /* excluding the header and null terminator */</span></span>\n<span class="line"><span>    unsigned char flags; /* 3 lsb of type, 5 unused bits */</span></span>\n<span class="line"><span>    char buf[];</span></span>\n<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结构:</p><blockquote><p>len:已使用长度</p><p>alloc总长度,不包括header和null终止符</p><p>flags:高三位为类型,低5位为未使用</p><p>buf[]. : 字符数组</p></blockquote><p>在redis6里面没有了free字段,因为可以通过alloc-len得到.</p><p><em>redisObject ptr指针指向buf的起始地址,通过减去一个char固定长度,得到类型和未使用长度.</em></p><h4 id="编码" tabindex="-1"><a class="header-anchor" href="#编码"><span>编码</span></a></h4><p>字符串对象编码有三种:</p><ul><li>int编码: 如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void* 转换成long），并将字符串对象的编码设置为int。</li><li>raw编码: 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</li><li>embstr编码: 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li></ul><blockquote><p><code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式，通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构，而<code>raw</code>编码会调用两次内存分配函数来分别创建。释放<code>embstr</code>编码字符串也只需要一次调用。</p></blockquote><figure><img src="'+l+'" alt="redis-string" tabindex="0" loading="lazy"><figcaption>redis-string</figcaption></figure><h3 id="应用" tabindex="-1"><a class="header-anchor" href="#应用"><span>应用</span></a></h3><blockquote><p>位图类应用:</p><ul><li>用户签到,如 sign_user:用户id。 签到成功设置对应的pos为1, 可以设置相对某一个时间的偏移量.</li><li>系统用户在线状态, 每个用户对应一个bit位</li><li>布隆过滤器</li><li>统计活跃用户: 每日一个bitmap, 如果要统计一段时间内的活跃用户,直接对多个bitmap进行or位运算</li><li>ip黑白名单</li><li>统计uv</li></ul></blockquote><p>注意事项:避免出现大key问题,对单个key进行拆分,先根据一定规则定位到key,然后再进行操作</p><h2 id="list列表" tabindex="-1"><a class="header-anchor" href="#list列表"><span>List列表</span></a></h2><h3 id="基础使用-1" tabindex="-1"><a class="header-anchor" href="#基础使用-1"><span>基础使用</span></a></h3><p>常规列表操作</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>LPUSH: 将元素添加到列表头部, RPUSH:将元素添加到列表尾部</span></span>\n<span class="line"><span>LPOP :将列表头部元素弹出,RPOP:将列表尾部元素弹出</span></span>\n<span class="line"><span>LLEN: 返回列表长度</span></span>\n<span class="line"><span>LMOVE: LMOVE mylist myotherlist RIGHT LEFT 将mylist的最后一个元素,移动到myotherlist的头部,LMOVE mylist myotherlist  LEFT RIGHT :将mylist的第一个元素,移动到myotherlist的尾部</span></span>\n<span class="line"><span>LRANGE: lrange key start end 返回列表指定区间的元素</span></span>\n<span class="line"><span>LTRIM: LTRIM KEY_NAME START STOP 保留指定区间的元素,其他元素删除</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>列表阻塞操作:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>BLPOP:从列表的头部删除并返回一个元素。如果列表为空，则命令将阻止，直到元素可用或达到指定的超时</span></span>\n<span class="line"><span>BLMOVE:以原子方式将元素从源列表移动到目标列表。如果源列表为空，则命令将阻塞，直到有新元素可用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="限制和性能" tabindex="-1"><a class="header-anchor" href="#限制和性能"><span>限制和性能</span></a></h3><blockquote><p>Redis 列表的最大长度为 2^32 - 1 （4,294,967,295） 个元素。</p></blockquote><h3 id="原理-1" tabindex="-1"><a class="header-anchor" href="#原理-1"><span>原理</span></a></h3><p>Redis的list支持两种编码方式: ZipList 和 LinkedList</p><p>适用条件:</p><ul><li>zipList <ul><li>所有键值对的长度都小于64个字节</li><li>键值对个数小于512个</li></ul></li><li>linkedList <ul><li>不符合zipList的情况</li></ul></li></ul><h3 id="应用-1" tabindex="-1"><a class="header-anchor" href="#应用-1"><span>应用</span></a></h3><blockquote><p>最近功能: 如最近浏览记录、最近访问记录、最近发布记录等</p><p>阻塞队列</p></blockquote><p>注意事项:</p><p><em>List在头尾操作比较快,涉及中部操作,如Lindex,Linsert,Lset等,在List比较大时,耗时比较严重.</em></p><h2 id="字典" tabindex="-1"><a class="header-anchor" href="#字典"><span>字典</span></a></h2><h3 id="基础使用-2" tabindex="-1"><a class="header-anchor" href="#基础使用-2"><span>基础使用</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>hget key field     获取field</span></span>\n<span class="line"><span>hset key field value 设置field</span></span>\n<span class="line"><span>hincrby key field step  对field增加step</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="原理-2" tabindex="-1"><a class="header-anchor" href="#原理-2"><span>原理</span></a></h3><h4 id="字典编码实现" tabindex="-1"><a class="header-anchor" href="#字典编码实现"><span>字典编码实现</span></a></h4><p>字典的编码方式有两种:ZipList和HashTable</p><p>适用条件:</p><ul><li>ZipList:同时满足以下条件 <ul><li>所有键值对的长度都小于64个字节</li><li>键值对个数小于512个</li></ul></li><li>HashTable <ul><li>不符合zipList的情况</li></ul></li></ul><h4 id="字典数据结构" tabindex="-1"><a class="header-anchor" href="#字典数据结构"><span>字典数据结构</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct dict{</span></span>\n<span class="line"><span>  //类型特定函数</span></span>\n<span class="line"><span>  dictType *type;</span></span>\n<span class="line"><span>  //私有数据</span></span>\n<span class="line"><span>  void *privdata;</span></span>\n<span class="line"><span>  //哈希表</span></span>\n<span class="line"><span>  dictht ht[2];</span></span>\n<span class="line"><span>  //rehash索引, 当rehash不再进行时,值为1</span></span>\n<span class="line"><span>  int rehashidx;</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="字典rehash过程" tabindex="-1"><a class="header-anchor" href="#字典rehash过程"><span>字典rehash过程</span></a></h4><p>rehash流程:</p><ul><li>为字典ht[1]分配空间 <ul><li>扩容: ht[1] 的空间为大于等于ht[0].used*2 的第一个2^n</li><li>缩容: ht[2]的空间为大于等于ht[0].used 的第一个2^n</li></ul></li><li>将字典ht[0]里面的数据rehash到ht[1]上面</li><li>当所有ht[0]里面的数据都rehash到ht[1]上面后,将ht[1]赋值给ht[0],然后将ht[1]设置为null</li></ul><p>rehash过程不是一次性的,而是渐进的,分多次进行.</p><ul><li>为ht[1]分配空间</li><li>将rehashidx设置为0,表示rehash开始</li><li>在rehash期间,每次对字典执行查询、更新、添加、删除时,除了完成对应操作,还会将ht[0]在rehashidx位置的数据全部rehash到ht[1]上,完成rehash后,将rehashidx值加1</li><li>当最后一个rehashidx位置的数据rehash完成后,将rehashidx设置为-1,表示rehash完成</li></ul><blockquote><p>在rehash过程,查找、更新、删除都会在两个哈希表上进行,新增只会在ht[1]上进行</p></blockquote><h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合"><span>集合</span></a></h2><h3 id="基础使用-3" tabindex="-1"><a class="header-anchor" href="#基础使用-3"><span>基础使用</span></a></h3><blockquote><p>A Redis set is an unordered collection of unique strings (members). You can use Redis sets to efficiently:</p><p>Redis set 是一个无序集合,存储字符串,每个字符串都是唯一的.支持如下高效操作:</p><ul><li>Track unique items (e.g., track all unique IP addresses accessing a given blog post).<br> 跟踪唯一项目（例如，跟踪访问给定博客文章的所有唯一 IP 地址）。</li><li>Represent relations (e.g., the set of all users with a given role).<br> 表示关系（例如，具有给定角色的所有用户的集合）。</li><li>Perform common set operations such as intersection, unions, and differences.<br> 执行常见的集作，例如交集、并集和差集。</li></ul><p>来自Redis官方</p></blockquote><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sadd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> member</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ...</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 新增元素</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">srem</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> member</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    删除元素</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SISMEMBER</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> member</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 判断是否存在,存在返回1,否则0</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sinter</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ...</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 返回集合交集,也是一个集合</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">scard</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 返回集合大小</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="限制和性能-1" tabindex="-1"><a class="header-anchor" href="#限制和性能-1"><span>限制和性能</span></a></h3><blockquote><p>Redis 集的最大大小为 2^32 - 1 （4,294,967,295） 个成员。</p></blockquote><h3 id="原理-3" tabindex="-1"><a class="header-anchor" href="#原理-3"><span>原理</span></a></h3><h4 id="集合编码实现" tabindex="-1"><a class="header-anchor" href="#集合编码实现"><span>集合编码实现</span></a></h4><p>集合支持两种编码:intset 和hashtable</p><p>适用条件:</p><ul><li>Intset: <ul><li>所有元素都是整数值</li><li>元素个数小于512</li></ul></li><li>hashtable <ul><li>不符合intset条件</li></ul></li></ul><h2 id="有序集合" tabindex="-1"><a class="header-anchor" href="#有序集合"><span>有序集合</span></a></h2><h3 id="原理-4" tabindex="-1"><a class="header-anchor" href="#原理-4"><span>原理</span></a></h3><h4 id="有序集合编码实现" tabindex="-1"><a class="header-anchor" href="#有序集合编码实现"><span>有序集合编码实现</span></a></h4><p>有序集合编码实现主要有两种:</p><ul><li>ziplist</li><li>skiplist</li></ul><p>适用条件</p><ul><li>ziplist <ul><li>所有元素的长度小于64字节</li><li>元素个数小于128个</li></ul></li><li>skiplist <ul><li>不符合zipList情况</li></ul></li></ul><h4 id="skiplist原理" tabindex="-1"><a class="header-anchor" href="#skiplist原理"><span>skiplist原理</span></a></h4><h5 id="理想跳跃表" tabindex="-1"><a class="header-anchor" href="#理想跳跃表"><span>理想跳跃表</span></a></h5><p>在理想情况下:</p><ul><li>最底层元素是一个单链表</li><li>从最底层往上,每一层的元素个数是之前一层的1/2</li></ul><h5 id="跳跃表数据结构" tabindex="-1"><a class="header-anchor" href="#跳跃表数据结构"><span>跳跃表数据结构</span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>#跳表节点</span></span>\n<span class="line"><span>typedef struct zskiplistNode {</span></span>\n<span class="line"><span>    sds ele;</span></span>\n<span class="line"><span>    double score;</span></span>\n<span class="line"><span>    struct zskiplistNode *backward;</span></span>\n<span class="line"><span>    #跳表表示level的数据</span></span>\n<span class="line"><span>    struct zskiplistLevel {</span></span>\n<span class="line"><span>        struct zskiplistNode *forward;</span></span>\n<span class="line"><span>        unsigned long span;</span></span>\n<span class="line"><span>    } level[];</span></span>\n<span class="line"><span>} zskiplistNode;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>#跳表 list结构</span></span>\n<span class="line"><span>typedef struct zskiplist {</span></span>\n<span class="line"><span>    struct zskiplistNode *header, *tail;</span></span>\n<span class="line"><span>    unsigned long length;</span></span>\n<span class="line"><span>    int level;</span></span>\n<span class="line"><span>} zskiplist;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>#zset 结构</span></span>\n<span class="line"><span>typedef struct zset {</span></span>\n<span class="line"><span>    dict *dict;</span></span>\n<span class="line"><span>    zskiplist *zsl;</span></span>\n<span class="line"><span>} zset;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>跳跃表的最大层数:32层</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&amp;mid=2247512204&amp;idx=4&amp;sn=8a2a24e139f1c5fdfcc0f017b280bd0e&amp;chksm=fbb13972ccc6b0647387c63c87acb6f638ce8c99dca30d958a4e91ed766224f50a32ec7281ad&amp;scene=27" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&amp;mid=2247512204&amp;idx=4&amp;sn=8a2a24e139f1c5fdfcc0f017b280bd0e&amp;chksm=fbb13972ccc6b0647387c63c87acb6f638ce8c99dca30d958a4e91ed766224f50a32ec7281ad&amp;scene=27</a></p>',102)]))}]]),r=JSON.parse('{"path":"/summary/base-components/redis/basic/data-types.html","title":"Redis数据结构与对象","lang":"zh-CN","frontmatter":{"typora-copy-images-to":"../images","description":"Redis数据结构与对象 在redis数据库中每个键值对key-value都是有对象组成的,其中key都是字符串对象,value对象类型有五种: 字符串对象、列表对象、哈希对象、集合对象、有序集合对象. 这五种数据对象是提供给用户直接使用的,其底层实现主要依赖以下8种数据结构: 简单动态字符串、字典表、双向链表、跳表、整数集合、压缩列表、快速列表 Re...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/notes-base/summary/base-components/redis/basic/data-types.html"}],["meta",{"property":"og:site_name","content":"Offer收割机"}],["meta",{"property":"og:title","content":"Redis数据结构与对象"}],["meta",{"property":"og:description","content":"Redis数据结构与对象 在redis数据库中每个键值对key-value都是有对象组成的,其中key都是字符串对象,value对象类型有五种: 字符串对象、列表对象、哈希对象、集合对象、有序集合对象. 这五种数据对象是提供给用户直接使用的,其底层实现主要依赖以下8种数据结构: 简单动态字符串、字典表、双向链表、跳表、整数集合、压缩列表、快速列表 Re..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-10T13:01:21.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-10T13:01:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis数据结构与对象\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-10T13:01:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Jason\\",\\"url\\":\\"https://jason.com\\"}]}"]]},"git":{"createdTime":1744361201000,"updatedTime":1746882081000,"contributors":[{"name":"Jason Statham","username":"Jason Statham","email":"xpt_notes@163.com","commits":2,"url":"https://github.com/Jason Statham"}]},"readingTime":{"minutes":9.51,"words":2853},"filePathRelative":"summary/base-components/redis/basic/data-types.md","localizedDate":"2025年4月11日","autoDesc":true}')},6995:(s,a)=>{a.A=(s,a)=>{const n=s.__vccOpts||s;for(const[s,i]of a)n[s]=i;return n}}}]);