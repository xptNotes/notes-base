# MySQL 锁使用

# Innodb锁介绍

## 锁分类

按操作粒度来分类:

- 全局锁
- 表锁
  - 普通表锁
  - 自增锁
- 行锁
  - 记录锁
  - gap锁
  - Next-key 锁
  - 插入意向锁

按操作类型分类:

- 读锁(S锁)
- 写锁(X锁)
- 意向锁





## 自增锁





## 行锁详解

MySQL的行级锁,是有存储引擎来实现的.在Innodb中行锁是通过给索引上的索引项加锁来实现.

所有行锁特点:  只有通过索引条件检索的数据,InnoDB才能使用行锁,否则使用表锁.



如何加行及锁?

- Insert\update\delete语句Innodb会自动给涉及的数据集加锁

- 普通select不涉及锁

- 事务中,可以通过select ** from xx for update 加排他锁, select ** from xx from share 加共享锁

  

### 插入意向锁 insert Intention Locks

一个事务在插入一条记录时需要判断一下插入位置是否被其他事务加了gap锁. 

如果已经被加了gap锁,当前插入就需要等待,直到当前位置的gap锁释放, 该插入等待,会在内存中生成一个锁结构,成为插入意向锁,表示当前gap有插入需求.



同一个gap区间,可以有多个插入意向锁,彼此不冲突.

插入意向锁也不会影响其它事务获取该记录(该gap的记录,不是要插入的记录)上的任何类型的锁.





### 记录锁 Record Locks



### Gap Locks 间隙锁

### Next-key Locks 临键锁







# 加锁分析(加锁规则)







## 不同隔离级别下的加锁分析







## 不同sql的













# 死锁案例分析



